Team Name: `97110347-97110144`

Student Name of member 1: `97110347`
Student No. of member 1: `متینا مهدیزاده`

Student Name of member 2: `97110144`
Student No. of member 2: `سید مهدی صادق شبیری`

- [x] Read Session Contents.

### Section 8.3
برای پیدا کردن سیستم‌کال‌ها و شناسه آن‌ها کد `find_syscall.c` به شکل زیر زده شده است.
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

const char* unistd_path = "/usr/include/asm-generic/unistd.h";
char* prefix = "#define __NR";
char* end_prefix = "#if __BITS_PER_LONG == 64 && !defined(__SYSCALL_COMPAT)";

int main() {
	FILE* file = fopen(unistd_path, "r");
	char line[1024];
	char name[1024];
	char* ids[1024];
	int ids_cnt = 0;
	int cnt = 0;
	if (file == NULL) {
		printf("file can't be opened \n");
	}
	
	char ch;
	do {
		ch = fgetc(file);
		line[cnt] = ch;
		cnt ++;
		if (ch == '\n' || ch == '\0')
		{
			line[cnt-1] = '\0';
			line[cnt] = '\0';
			if (strncmp(line, end_prefix, strlen(end_prefix)) == 0)
				break;
			if (strncmp(line, prefix, strlen(prefix)) == 0) 
			{
				int under_lines = 0;
				int i = 0;
				int name_cnt = 0;
				while (under_lines < 3) {
					if (line[i] == '_')
						under_lines ++;
					i ++;
				}	
				while (line[i] != ' ') {
					name[name_cnt] = line[i];
					name_cnt ++;
					i ++;
				}	
				name[name_cnt] = '\0';
				printf("\"%s\",", name);
				ids[ids_cnt] = malloc(strlen(line+i)+1);
				strcpy(ids[ids_cnt++], line+i);
			}
			cnt = 0;
		}
	}while (ch != EOF);
	printf("\n\n");
	for (int i = 0; i < ids_cnt; i++) {
		printf("%s,", ids[i]);
	}
	printf("\n");
	printf("number of syscall: %d\n", ids_cnt);
}
```
علت اینکه این عملیات را در کرنل ماژول انجام ندادیم این است که بهتر است در کرنل ماژول عملیات io نداشته باشیم.  
این کد از هدر unistd خط‌ها را می‌خواند و خط‌هایی که با `#define __NR` شروع شدن را پارس می‌کند و اسم و شناسه سیسکال را چاپ می‌کند.  
خروجی این کد به این شکل است
![image](https://user-images.githubusercontent.com/36403983/184083328-277d773b-95cf-4d1a-aa85-7f7180ab1d78.png)

کد کنرل ماژول در `table_addr.c` ذخیره شده است.  
```cpp
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/kallsyms.h>
#include <linux/kprobes.h>

const char* unistd_path = "/usr/include/asm-generic/unistd.h";

static struct kprobe kp = {
	.symbol_name = "kallsyms_lookup_name"
};

char* names[319] = {
	"io_setup","io_destroy","io_submit","io_cancel","io_getevents","setxattr","lsetxattr","fsetxattr","getxattr","lgetxattr","fgetxattr","listxattr","llistxattr","flistxattr","removexattr","lremovexattr","fremovexattr","getcwd","lookup_dcookie","eventfd2","epoll_create1","epoll_ctl","epoll_pwait","dup","dup3","fcntl","inotify_init1","inotify_add_watch","inotify_rm_watch","ioctl","ioprio_set","ioprio_get","flock","mknodat","mkdirat","unlinkat","symlinkat","linkat","renameat","umount2","mount","pivot_root","nfsservctl","statfs","fstatfs","truncate","ftruncate","fallocate","faccessat","chdir","fchdir","chroot","fchmod","fchmodat","fchownat","fchown","openat","close","vhangup","pipe2","quotactl","getdents64","lseek","read","write","readv","writev","pread64","pwrite64","preadv","pwritev","sendfile","pselect6","ppoll","signalfd4","vmsplice","splice","tee","readlinkat","fstatat","fstat","sync","fsync","fdatasync","sync_file_range2","sync_file_range","timerfd_create","timerfd_settime","timerfd_gettime","utimensat","acct","capget","capset","personality","exit","exit_group","waitid","set_tid_address","unshare","futex","set_robust_list","get_robust_list","nanosleep","getitimer","setitimer","kexec_load","init_module","delete_module","timer_create","timer_gettime","timer_getoverrun","timer_settime","timer_delete","clock_settime","clock_gettime","clock_getres","clock_nanosleep","syslog","ptrace","sched_setparam","sched_setscheduler","sched_getscheduler","sched_getparam","sched_setaffinity","sched_getaffinity","sched_yield","sched_get_priority_max","sched_get_priority_min","sched_rr_get_interval","restart_syscall","kill","tkill","tgkill","sigaltstack","rt_sigsuspend","rt_sigaction","rt_sigprocmask","rt_sigpending","rt_sigtimedwait","rt_sigqueueinfo","rt_sigreturn","setpriority","getpriority","reboot","setregid","setgid","setreuid","setuid","setresuid","getresuid","setresgid","getresgid","setfsuid","setfsgid","times","setpgid","getpgid","getsid","setsid","getgroups","setgroups","uname","sethostname","setdomainname","getrlimit","setrlimit","getrusage","umask","prctl","getcpu","gettimeofday","settimeofday","adjtimex","getpid","getppid","getuid","geteuid","getgid","getegid","gettid","sysinfo","mq_open","mq_unlink","mq_timedsend","mq_timedreceive","mq_notify","mq_getsetattr","msgget","msgctl","msgrcv","msgsnd","semget","semctl","semtimedop","semop","shmget","shmctl","shmat","shmdt","socket","socketpair","bind","listen","accept","connect","getsockname","getpeername","sendto","recvfrom","setsockopt","getsockopt","shutdown","sendmsg","recvmsg","readahead","brk","munmap","mremap","add_key","request_key","keyctl","clone","execve","mmap","fadvise64","swapon","swapoff","mprotect","msync","mlock","munlock","mlockall","munlockall","mincore","madvise","remap_file_pages","mbind","get_mempolicy","set_mempolicy","migrate_pages","move_pages","rt_tgsigqueueinfo","perf_event_open","accept4","recvmmsg","arch_specific_syscall","wait4","prlimit64","fanotify_init","fanotify_mark","name_to_handle_at","open_by_handle_at","clock_adjtime","syncfs","setns","sendmmsg","process_vm_readv","process_vm_writev","kcmp","finit_module","sched_setattr","sched_getattr","renameat2","seccomp","getrandom","memfd_create","bpf","execveat","userfaultfd","membarrier","mlock2","copy_file_range","preadv2","pwritev2","pkey_mprotect","pkey_alloc","pkey_free","statx","io_pgetevents","rseq","kexec_file_load","clock_gettime64","clock_settime64","clock_adjtime64","clock_getres_time64","clock_nanosleep_time64","timer_gettime64","timer_settime64","timerfd_gettime64","timerfd_settime64","utimensat_time64","pselect6_time64","ppoll_time64","io_pgetevents_time64","recvmmsg_time64","mq_timedsend_time64","mq_timedreceive_time64","semtimedop_time64","rt_sigtimedwait_time64","futex_time64","sched_rr_get_interval_time64","pidfd_send_signal","io_uring_setup","io_uring_enter","io_uring_register","open_tree","move_mount","fsopen","fsconfig","fsmount","fspick","pidfd_open","clone3","close_range","openat2","pidfd_getfd","faccessat2","process_madvise","syscalls"};
int ids[319] = {
	 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 260, 261, 262, 263,         264,         265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441};


static int __init ker_init(void) {
	printk(KERN_INFO "hello\n");


	/// init kallsyms
	typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
	kallsyms_lookup_name_t kallsyms_lookup_name;
	register_kprobe(&kp);
	kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
	unregister_kprobe(&kp);
	unsigned long* table = (unsigned long*) kallsyms_lookup_name("sys_call_table");
	for (int i = 0; i < 319; i++){
		printk(KERN_INFO "address of %s is %lu\n", names[i], table[ids[i]]);
	}
	return 0;
}

static void __exit ker_exit(void) {
	printk(KERN_INFO "bye\n");
}

module_init(ker_init);
module_exit(ker_exit);
MODULE_LICENSE("GPL v2");
```
در ابتدای این کد لیست سیستم‌کال‌ها که توسط `find_syscalls` پیدا شده است در دو آرایه `names` و `ids` قرار داده شده است.  
چون تابع `kallsyms_lookup_name` از کرنل 5.7 به بعد export نشده است باید به صورت دستی به آن دسترسی پیدا کنیم. برای همین این تیکه کد زده شده است.
```c
static struct kprobe kp = {
	.symbol_name = "kallsyms_lookup_name"
};
...
typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
kallsyms_lookup_name_t kallsyms_lookup_name;
register_kprobe(&kp);
kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
unregister_kprobe(&kp);
```
در نهایت آدرس جدول سیستم‌کال‌ها در `table` ریخته می‌شود. سپس برای هر سیستم کال آدرس تابع آن را چاپ می‌کند.  
برای تست و کامپایل Makefile زیر نوشته شده است  
```Makefile
obj-m += table_addr.o
all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
test:
	sudo dmesg -C
	sudo insmod table_addr.ko
	sudo rmmod table_addr.ko
	sudo dmesg -c
```
با دستور `make` کد کامپایل می‌شود و در کرنل بارگذاری می‌شود.  
با دستور `make clean` فایل‌های کامپایل شده پاک می‌شود و از کرنل نیز حذف می‌شود.  
با دستور `dmesg -C` خروجی `dmesg` خالی می‌شود.  
با دستور `insmod table_addr.ko` کرنل ماژول اضافه و با دستور `rmod table_addr.ko` حذف می‌شود.  
در نهایت با `dmesg -c` خروجی `dmesg` را چاپ می‌کند و لاگ‌ها را پاک می‌کند.

خروجی
![image](https://user-images.githubusercontent.com/36403983/184085340-146b68e0-b58c-4abe-a9cf-42734d762ee9.png)

نیازمندی‌های لازم  
```commandline
apt-get install build-essential linux-headers-`uname -r`
```
- [1] [1.zip](https://github.com/SmsS4/os-lab-reports/files/9306974/1.zip)
### Section 8.4
- [ ] Upload a zip file including needed materials
